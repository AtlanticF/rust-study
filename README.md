Study rust from [trpl](https://kaisery.github.io/trpl-zh-cn/)

- ç¼–è¯‘ï¼šrustc
- åŒ…ç®¡ç†ï¼šcargo build / run / new / update
    - Cargo.xml: dependences (SemVer) è¯­ä¹‰åŒ–ç‰ˆæœ¬å·
    - Cargo.lock: æž„å»ºå¯é‡çŽ°

## ä¸€ã€ä¸€äº›æ¦‚å¿µ

### 1.1 å˜é‡

- ä½¿ç”¨ let ç”³æ˜Ž
- å˜é‡é»˜è®¤æ˜¯ immutableï¼ˆä¸å¯å˜ï¼‰çš„
- ä½¿ç”¨ let mut ç”³æ˜Žå¯å˜å˜é‡

### 1.2 å¸¸é‡

- ä½¿ç”¨ const ç”³æ˜Ž
- å¸¸é‡æ€»æ˜¯ä¸èƒ½å˜
- å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸä¸­ç”³æ˜Žï¼ŒåŒ…æ‹¬å…¨å±€
- çº¦å®šæ˜¯åœ¨å•è¯ä¹‹é—´ä½¿ç”¨å…¨å¤§å†™åŠ ä¸‹åˆ’çº¿
- ç¼–è¯‘æ—¶è®¡ç®—
- åœ¨ç”³æ˜Žçš„ä½œç”¨åŸŸä¸­ï¼Œå¸¸é‡åœ¨æ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸä¸­éƒ½æœ‰æ•ˆ

### 1.3 éšè—ï¼ˆshadowingï¼‰

- å®šä¹‰ä¸€ä¸ªä¸Žä¹‹å‰å˜é‡åŒåçš„æ–°å˜é‡çš„è¡Œä¸ºï¼Œç§°ä¸º shadowing
- mut ä¸Ž shadowing æœ‰åŒºåˆ«
    - ä¸ä½¿ç”¨ let å¯¹ **ä¸å¯å˜** å˜é‡è¿›è¡Œé‡æ–°èµ‹å€¼æ—¶ä¼šæŠ¥é”™
    - shadowing å®žé™…åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå¯ä»¥æ”¹å˜ **å€¼** ç±»åž‹ï¼Œå¹¶ä¸”å¤ç”¨è¿™ä¸ªåå­—

### 1.4 æ•°æ®ç±»åž‹

#### 1.4.1 æ ‡é‡ scaler: å•ç‹¬çš„å€¼

- æ•´åž‹
    - é»˜è®¤ i32
    - 8ï¼Œ16ï¼Œ32ï¼Œ64ï¼Œ128 bit æœ‰æ— ç¬¦å·
    - arch æœ‰æ— ç¬¦å·: isize usizeï¼Œä¾èµ– CPU æž¶æž„
    - å…è®¸ `_` åˆ†éš”ç¬¦: 1_000 = 1000
    - integer overflow
        - åœ¨ debug æž„å»ºä¸­äº§ç”Ÿ panic
        - åœ¨ release æž„å»ºä¸­å‘ç”Ÿ warpping æ“ä½œ
- æµ®ç‚¹åž‹
    - f32, f64 ä½¿ç”¨ IEEE-754 æ ‡å‡†è¡¨ç¤º
    - é»˜è®¤ f64
- å¸ƒå°”
    - true, false
- å­—ç¬¦
    - å•å¼•å·
    - å 4å­—èŠ‚
    - ä»£è¡¨ä¸€ä¸ª Unicode æ ‡é‡å€¼

#### 1.4.2 å¤åˆ compound: å¤šä¸ªå€¼ç»„åˆ

- å…ƒç»„ tuple
    - let tup = (100, 2.0, 1) / let tup: (i32, u32, f64) = (-2, 1, 2.3)
    - å£°æ˜ŽåŽé•¿åº¦ä¸å˜
    - å„å…ƒç´ ç±»åž‹å¯ä»¥ä¸åŒ
    - let (x, y, z) = tup ç§°ä¹‹ä¸º destructure
    - é€šè¿‡ `.` è®¿é—®å…ƒç´ 
- æ•°ç»„ array
    - [] ç”³æ˜Ž
    - æ•°ç»„å†…å„å…ƒç´ ç±»åž‹å¿…é¡»ç›¸åŒ
    - ä¸å¯å˜é•¿åº¦
    - let a: [i32; 5] = [1, 2, 3, 4, 5]
    - let a = [3; 5] é•¿åº¦ä¸º 5 çš„æ•°ç»„ï¼Œå…ƒç´ éƒ½ä¸º 3
    - a[index] è®¿é—®
    - index out of boundsï¼šè¿è¡Œæ—¶é”™è¯¯ï¼Œpanic

### 1.5 å‡½æ•°

`snake case` è§„èŒƒé£Žæ ¼ï¼Œå°å†™åŠ ä¸‹åˆ’çº¿åˆ†éš”å•è¯

#### 1.5.1 å‚æ•°

- parameter å’Œ argument

#### 1.5.2 è¯­å¥å’Œè¡¨è¾¾å¼

- å‡½æ•°ä½“ = è¯­å¥ + å¯é€‰çš„ç»“æŸè¡¨è¾¾å¼
- Rust æ˜¯ expression-based è¯­è¨€
- Statements æ‰§è¡Œæ“ä½œï¼Œä¸è¿”å›žå€¼çš„ æŒ‡ä»¤
- Expression è®¡ç®—å¹¶äº§ç”Ÿä¸€ä¸ªå€¼ 
- è¡¨è¾¾å¼å¯ä»¥æ˜¯è¯­å¥çš„ä¸€éƒ¨åˆ†: let x = 6
- å‡½æ•°éšå¼è¿”å›žæœ€åŽçš„ **è¡¨è¾¾å¼**

#### 1.5.3 æ³¨é‡Š

- `//`

#### 1.5.4 æŽ§åˆ¶æµ

- åˆ¤æ–­ **è¡¨è¾¾å¼**: if
- if (expression) expression å¿…é¡»ä¸º bool
- å› ä¸ºæ˜¯è¡¨è¾¾å¼ï¼Œæ‰€ä»¥å…·æœ‰è¿”å›žå€¼: let number = if condition {1} else {2};
- åˆ†æ”¯è¡¨è¾¾å¼è¿”å›žå€¼ç±»åž‹å¿…é¡»ç›¸åŒ

- loop
- å¾ªçŽ¯æ ‡ç­¾ 'counting_up: loop {} -- æ¶ˆé™¤å¤šä¸ªå¾ªçŽ¯ä¹‹é—´çš„æ­§ä¹‰
- while æ¡ä»¶å¾ªçŽ¯
- for éåŽ†é›†åˆ for element in a {}
- for number in (1..4).rev() {}

## äºŒã€æ‰€æœ‰æƒï¼ˆOwnershipï¼‰

å˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼ï¼šå°†å€¼èµ‹ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ç§»åŠ¨å®ƒã€‚å½“æŒæœ‰å †ä¸­æ•°æ®å€¼çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå…¶å€¼å°†é€šè¿‡ drop è¢«æ¸…ç†æŽ‰ï¼Œé™¤éžæ•°æ®è¢«ç§»åŠ¨ä¸ºå¦ä¸€ä¸ªå˜é‡æ‰€æœ‰ã€‚

å®˜æ–¹çš„è¯´æ³•ï¼šæ²¡æœ‰ GCï¼Œæ— éœ€æ‰‹åŠ¨åˆ†é…å’Œé‡Šæ”¾ã€‚ä¾èµ– ownership ç³»ç»Ÿç®¡ç†ï¼Œ`wonership ä»»ä½•åŠŸèƒ½éƒ½ä¸ä¼šå‡æ…¢ç¨‹åº`ã€‚è·Ÿè¸ªä»£ç æ­£åœ¨ä½¿ç”¨çš„ `å †` ä¸Šçš„æ•°æ®ï¼Œæœ€å¤§é™åº¦å‡å°‘å †ä¸Š `é‡å¤` æ•°æ®çš„é‡ï¼Œå¹¶ä¸”æ¸…ç†å †ä¸Šä¸å†ä½¿ç”¨çš„æ•°æ®ã€‚

ownership æ˜¯ rust å†…å­˜ç®¡ç†çš„ä¸€ç§å®žçŽ°ã€‚åŒºåˆ«äºŽ GC å’Œæ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œownership ä¸ºæ¯å—è¢«åˆ†é…çš„å†…å­˜å®šä¹‰äº†ä½œç”¨åŸŸå’Œæ‰€æœ‰è€…ï¼Œ`(å †ä¸Š)å†…å­˜åœ¨æ‹¥æœ‰å®ƒçš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸåŽå°±è¢«è‡ªåŠ¨é‡Šæ”¾`

ç†è§£ï¼š`heap ä¸Šåˆ†é…çš„å†…å­˜`æŒ‡å‘çš„å˜é‡ï¼Œrust ä¼šä½¿ç”¨ `ownership` ç®¡ç†èµ·æ¥ï¼Œå½“å˜é‡`ç¦»å¼€ä½œç”¨åŸŸ`æ—¶ï¼Œè°ƒç”¨ `drop` è‡ªåŠ¨æ¸…ç†å˜é‡çš„å †å†…å­˜ã€‚

å…³äºŽäºŒæ¬¡é‡Šæ”¾ï¼ˆdouble freeï¼‰ï¼š
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    // stack ä¸Š s1 æ ‡è®°ä¸ºæ— æ•ˆï¼Œæ­¤æ—¶æ— æ³•ä½¿ç”¨ s1
    // ä¹Ÿå¯ä»¥ç†è§£ä¸º s1 çš„ ownership move åˆ° s2 äº†

    println!("{}, world!", s1);
}
```
 
### 2.1 ä¸‰ä¸ªè§„åˆ™

- Rust ä¸­æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ª **æ‰€æœ‰è€…ï¼ˆOwnerï¼‰**
- å€¼åœ¨ä»»ä½•æ—¶åˆ»éƒ½åªæœ‰ **ä¸€ä¸ª** æ‰€æœ‰è€…
- å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼è¢«æŠ›å¼ƒ

### 2.2 å˜é‡ä½œç”¨åŸŸ

å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼ŒRust ä¸ºæˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å«åš drop

### 2.3 ç§»åŠ¨

```rust
let x = 5;
let y = x;

let s1 = String::from("hello");
let s2 = s1;
```
![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-01.svg)
![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-02.svg)
![move](https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg)

### 2.4 å…‹éš†

éœ€æ±‚ï¼šéœ€è¦æ·±åº¦å¤åˆ¶æŸå˜é‡å †ä¸Šæ•°æ®

ä½¿ç”¨ï¼š
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    // æ­¤æ—¶ s1ï¼Œs2 å‡æœ‰æ•ˆï¼Œs1 ownership å¹¶æ²¡æœ‰ move
    // å †ä¸Šç”³è¯·äº†ä¸¤ä»½å†…å­˜ï¼Œå­˜å‚¨ "hello"
    println!("s1 = {}, s2 = {}", s1, s2);
}
```

### 2.5 Copy

åƒæ•´åž‹è¿™æ ·çš„åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°çš„ç±»åž‹è¢«æ•´ä¸ªå­˜å‚¨åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥æ‹·è´å…¶å®žé™…çš„å€¼æ˜¯å¿«é€Ÿçš„ã€‚

å®žçŽ°ï¼š`Copy trait` æ³¨è§£ã€‚ä»»ä½•ä¸€ç»„ç®€å•æ ‡é‡å€¼çš„ç»„åˆéƒ½å¯ä»¥å®žçŽ° Copyã€‚

### 2.6 æ‰€æœ‰æƒå’Œå‡½æ•°

```rust
fn main() {
    let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ

    takes_ownership(s);             // s çš„ å€¼ ç§»åŠ¨åˆ°å‡½æ•°é‡Œï¼Œs å¤±æ•ˆï¼Œsome_string æœ‰æ•ˆ
                                    // some_string = s
                                    // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ

    let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ

    makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                    // ä½† i32 æ˜¯ Copy çš„ï¼Œ
                                    // æ‰€ä»¥åœ¨åŽé¢å¯ç»§ç»­ä½¿ç”¨ x

} // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åŽæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
  // æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
} // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚
  // å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
} // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„
```

### 2.6 æ‰€æœ‰æƒå’Œä½œç”¨åŸŸ

è¿”å›žå€¼ä¹Ÿå¯ä»¥è½¬ç§»æ‰€æœ‰æƒã€‚

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership å°†è¿”å›žå€¼
                                        // è½¬ç§»ç»™ s1

    let s2 = String::from("hello");     // s2 è¿›å…¥ä½œç”¨åŸŸ

    let s3 = takes_and_gives_back(s2);  // s2 è¢«ç§»åŠ¨åˆ°
                                        // takes_and_gives_back ä¸­,
                                        // å®ƒä¹Ÿå°†è¿”å›žå€¼ç§»ç»™ s3
} // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {             // gives_ownership ä¼šå°†
                                             // è¿”å›žå€¼ç§»åŠ¨ç»™
                                             // è°ƒç”¨å®ƒçš„å‡½æ•°

    let some_string = String::from("yours"); // some_string è¿›å…¥ä½œç”¨åŸŸ.

    some_string                              // è¿”å›ž some_string 
                                             // å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}

// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›žè¯¥å€¼
fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ
    a_string  // è¿”å›ž a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}
```
é—®é¢˜ï¼šç»§ç»­ä½¿ç”¨æ‰€æœ‰æƒè½¬ç§»å‰çš„å‚æ•°æ˜¯å¸¸è§çš„éœ€æ±‚ï¼Œæ¯æ¬¡è½¬ç§»å†è¿”å›žç•¥æ˜¾å•°å—¦ï¼Œå¦‚æžœä½¿ç”¨ä½¿ç”¨ tuple ä¹Ÿæ˜¯å¤æ‚ï¼Œå¦‚ä½•æ›´ä¼˜é›…åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ
Rust æå‡º **borrowing** å’Œ **references**

## ä¸‰ã€å¼•ç”¨å’Œå€Ÿç”¨

### 3.1 æ¦‚å¿µ

å¼•ç”¨ï¼ˆreferenceï¼‰åƒä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæ˜¯ä¸€ä¸ªåœ°å€ï¼Œå¯ä»¥ç”±æ­¤è®¿é—®å‚¨å­˜äºŽè¯¥åœ°å€çš„å±žäºŽå…¶ä»–å˜é‡çš„æ•°æ®ã€‚å…è®¸ä½ ä½¿ç”¨å€¼ä½†ä¸èŽ·å–å…¶æ‰€æœ‰æƒã€‚

ç†è§£ï¼šçŒœæµ‹å®žçŽ°ï¼Œrust å»ºç«‹å¼•ç”¨ï¼Œä½†æ˜¯å¹¶ä¸ä¼šå°†å¼•ç”¨ä¸Žå€¼åšç»‘å®šï¼ˆèµ‹äºˆå¼•ç”¨å€¼çš„æ‰€æœ‰æƒï¼‰ï¼Œæ‰€ä»¥å¼•ç”¨åœ¨ç¦»å¼€å…¶ä½œç”¨åŸŸçš„æ—¶å€™ä¹Ÿä¸ä¼šè¿›è¡Œ drop

åˆ›å»ºä¸€ä¸ªå¼•ç”¨çš„è¡Œä¸ºï¼š**å€Ÿç”¨ï¼ˆborrowingï¼‰**
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
// è¿™é‡Œï¼Œs ç¦»å¼€äº†ä½œç”¨åŸŸã€‚ä½†å› ä¸ºå®ƒå¹¶ä¸æ‹¥æœ‰å¼•ç”¨å€¼çš„æ‰€æœ‰æƒï¼Œ
// æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿï¼ˆå¼•ç”¨ç¦»å¼€ä½œç”¨åŸŸä¸ä¼š dropï¼Œå› ä¸ºä¸å…·æœ‰æ‰€æœ‰æƒï¼‰
```
![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-05.svg)

`æ­£å¦‚å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå¼•ç”¨ä¹Ÿä¸€æ ·ã€‚ï¼ˆé»˜è®¤ï¼‰ä¸å…è®¸ä¿®æ”¹å¼•ç”¨çš„å€¼ã€‚å€Ÿçš„ä¸œè¥¿ä¸èƒ½éšæ„æ”¹å˜ï¼Œè¿™é‡Œç†æ‰€å½“ç„¶çš„ã€‚`

ðŸ¤” æ€è€ƒï¼šé€šè¿‡ä¼ é€’å¯å˜çš„å¼•ç”¨æ˜¯å¦å¯ä»¥ä¿®æ”¹ä¸å¯è¾¨çš„å˜é‡ï¼ŸNo: ä¸å¯å˜å˜é‡å°±æ˜¯ä¸å¯å˜

### 3.2 å¯å˜å¼•ç”¨

å¯å˜å¼•ç”¨çš„é™åˆ¶ï¼šå¦‚æžœä½ æœ‰ä¸€ä¸ªå¯¹è¯¥å˜é‡çš„**å¯å˜å¼•ç”¨**ï¼Œ**åœ¨åŒä¸€ä½œç”¨åŸŸ**ï¼Œä½ å°±ä¸èƒ½å†åˆ›å»ºå¯¹è¯¥å˜é‡çš„**å¼•ç”¨**ã€‚

è®¾è®¡ç›®çš„ï¼šé¿å… data race æ•°æ®ç«žäº‰å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚é˜²æ­¢åŒä¸€æ—¶é—´å¯¹åŒä¸€æ•°æ®å­˜åœ¨å¤šä¸ªå¯å˜å¼•ç”¨ã€‚

é€ æˆ data race åŽŸå› ï¼š
- ä¸¤ä¸ªæˆ–å¤šä¸ªæŒ‡é’ˆ`åŒæ—¶`è®¿é—®åŒä¸€æ•°æ®
- è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆè¢«ç”¨æ¥å†™æ•°æ®
- æ²¡æœ‰åŒæ­¥æ•°æ®è®¿é—®çš„æœºåˆ¶

å¤šä¸ªä¸å¯å˜å¼•ç”¨æ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºæ²¡æœ‰å“ªä¸ªåªèƒ½è¯»å–æ•°æ®çš„äººæœ‰èƒ½åŠ›å½±å“å…¶ä»–äººè¯»å–åˆ°çš„æ•°æ®ã€‚

å¼•ç”¨çš„ä½œç”¨åŸŸä»Žå£°æ˜Žçš„åœ°æ–¹å¼€å§‹ä¸€ç›´æŒç»­åˆ°æœ€åŽä¸€æ¬¡ä½¿ç”¨ä¸ºæ­¢ã€‚ç¼–è¯‘å™¨åœ¨ä½œç”¨åŸŸç»“æŸä¹‹å‰åˆ¤æ–­ä¸å†ä½¿ç”¨çš„å¼•ç”¨çš„èƒ½åŠ›è¢«ç§°ä¸º **éžè¯æ³•ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸ**ï¼ˆNon-Lexical Lifetimesï¼Œç®€ç§° NLLï¼‰ã€‚

```rust
fn main() {
    // å¯å˜å˜é‡
    let mut s = String::from("hello");
    // å¢žåŠ  mut -> åˆ›å»ºå¯å˜å¼•ç”¨ s
    change(&mut s);
}

fn change(some_string: &mut String) {
    // æ”¹å˜å¼•ç”¨ somg_string æŒ‡å‘çš„å†…å­˜çš„å€¼
    some_string.push_str(", world");
}
```

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // æ²¡é—®é¢˜
    let r2 = &s; // æ²¡é—®é¢˜
    println!("{} and {}", r1, r2);
    // æ­¤ä½ç½®ä¹‹åŽ r1 å’Œ r2 ä¸å†ä½¿ç”¨ï¼ˆåŽç»­ä»£ç ä¸­æ²¡æœ‰ r1 å’Œ r2ï¼Ÿï¼‰

    let r3 = &mut s; // æ²¡é—®é¢˜
    println!("{}", r3);
}
```

### 3.3 åž‚æ‚¬å¼•ç”¨

æ‚¬åž‚æŒ‡é’ˆï¼šå…¶æŒ‡å‘çš„å†…å­˜å¯èƒ½å·²ç»è¢«åˆ†é…ç»™å…¶å®ƒæŒæœ‰è€…ã€‚
åœ¨ Rust ä¸­ç¼–è¯‘å™¨ç¡®ä¿å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šå˜æˆæ‚¬åž‚çŠ¶æ€ï¼šå½“ä½ æ‹¥æœ‰ä¸€äº›æ•°æ®çš„å¼•ç”¨ï¼Œç¼–è¯‘å™¨ç¡®ä¿æ•°æ®ä¸ä¼šåœ¨å…¶å¼•ç”¨ä¹‹å‰ç¦»å¼€ä½œç”¨åŸŸã€‚

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    // s åˆ›å»º
    let s = String::from("hello");
    // å°è¯•è¿”å›ž s çš„å¼•ç”¨
    &s
} // s ç¦»å¼€ä½œç”¨åŸŸï¼Œdrop è°ƒç”¨ï¼Œå†…å­˜é‡Šæ”¾ï¼Œæ­¤æ—¶ &s åž‚æ‚¬
```

### 3.4 å¼•ç”¨è§„åˆ™

- åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼ˆä½œç”¨åŸŸï¼‰ï¼Œè¦ä¹ˆ åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆ åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚
- å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚ï¼ˆç¼–è¯‘å™¨ä¿è¯æ²¡æœ‰åž‚æ‚¬å¼•ç”¨ï¼‰ã€‚

## å››ã€Slice ç±»åž‹

Slice å…è®¸å¼•ç”¨é›†åˆä¸­ä¸€æ®µ`è¿žç»­çš„`å…ƒç´ åºåˆ—ã€‚slice æ˜¯ä¸€ç±»å¼•ç”¨ï¼Œ`æ²¡æœ‰æ‰€æœ‰æƒ`ã€‚

é—®é¢˜ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æŽ¥æ”¶ä¸€ä¸ªç”¨ç©ºæ ¼åˆ†éš”å•è¯çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›žåœ¨è¯¥å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªå•è¯ã€‚å¦‚æžœå‡½æ•°åœ¨è¯¥å­—ç¬¦ä¸²ä¸­å¹¶æœªæ‰¾åˆ°ç©ºæ ¼ï¼Œåˆ™æ•´ä¸ªå­—ç¬¦ä¸²å°±æ˜¯ä¸€ä¸ªå•è¯ï¼Œæ‰€ä»¥åº”è¯¥è¿”å›žæ•´ä¸ªå­—ç¬¦ä¸²ã€‚

```rust
fn first_word_idx(s: &String) -> usize {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    s.len()
}
fn main() {
    let mut s = String::from("helo world");
    let word = first_word_index(&s);
    s.clear();
    // word å€¼ä»ç„¶æ˜¯ 5
    // å› ä¸º s æ— æ•ˆäº†ï¼Œæ­¤å¤„ 5 ä¹Ÿæ²¡æœ‰æ„ä¹‰äº†
}
```

### 4.1 å­—ç¬¦ä¸² slice

```rust
let s = String::from("hello world");
// [0,5) [6,11)
// len = end - start
let hello = &s[0..5]; // hello -> reference -> 'hello'
let world = &s[6..11]; // world -> reference -> 'world'
```

    æ³¨æ„ï¼šå­—ç¬¦ä¸² slice range çš„ç´¢å¼•å¿…é¡»ä½äºŽæœ‰æ•ˆçš„ UTF-8 å­—ç¬¦è¾¹ç•Œå†…ï¼Œå¦‚æžœå°è¯•ä»Žå­—æŽ¥å­—ç¬¦çš„ä¸­é—´ä½ç½®åˆ›å»ºå­—ç¬¦ä¸² sliceï¼Œåˆ™ç¨‹åºå°†ä¼šå› é”™è¯¯è€Œé€€å‡ºã€‚ï¼ˆç†è§£ï¼šslice range æ˜¯å•å­—èŠ‚çš„ï¼‰

```rust
// string slice range å•å­—èŠ‚

let s = String::from("ä¸­"); // hex:E4B8AD -> 3bytes
let c = &s[0..1];
println!("ä¸­ slice[0..1] is {}", c);
```

String variable, String reference, String reference å¯¹æ¯”ï¼š

- String variable: {ptr, len, capacity}
- String reference: {ptr}
- String slice: {ptr, len}

```rust
// &str ä»£è¡¨ string slice
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}
fn main() {
    let mut s = String::from("hello world");
    // èŽ·å–äº† s çš„ä¸å¯å˜å¼•ç”¨ -> world
    let world = first_word(&s);
    s.clear(); // æ¸…ç©ºä¼šå°è¯•èŽ·å–ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œç¼–è¯‘é”™è¯¯
    // è¿˜è¦ä½¿ç”¨ worldï¼Œæ ¹æ® NLL æ­¤æ—¶ world ä¸å¯å˜å¼•ç”¨ä¾ç„¶æœ‰æ•ˆ
    println!("the first world is: {}", world);
}
```

### 4.2 å­—ç¬¦ä¸²çš„å­—é¢å€¼å°±æ˜¯ slice

```rust
let s = "Hello world";
```

ä¸ºä»€ä¹ˆå­—ç¬¦ä¸²å­—é¢å€¼ä¸å¯å˜ï¼Ÿå› ä¸ºæ˜¯ &str ç±»åž‹ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ã€‚


### 4.3 å­—ç¬¦ä¸² slice ä½œå‚æ•°

```rust
// deref coercions
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}

fn main() {
    let my_string = String::from("hello world");

    // `first_word` é€‚ç”¨äºŽ `String`ï¼ˆçš„ sliceï¼‰ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` ä¹Ÿé€‚ç”¨äºŽ `String` çš„å¼•ç”¨ï¼Œ
    // è¿™ç­‰ä»·äºŽæ•´ä¸ª `String` çš„ slice
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` é€‚ç”¨äºŽå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // å› ä¸ºå­—ç¬¦ä¸²å­—é¢å€¼å·²ç» **æ˜¯** å­—ç¬¦ä¸² slice äº†ï¼Œ
    // è¿™ä¹Ÿæ˜¯é€‚ç”¨çš„ï¼Œæ— éœ€ slice è¯­æ³•ï¼
    let word = first_word(my_string_literal);
}
```

### 4.4 å…¶ä»–ç±»åž‹çš„ slice

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let slice = &a[1..3];

    assert_eq!(slice, &[2, 3]);
}
```

## äº”ã€ç»“æž„ä½“ Struct

- structure æ˜¯ä»€ä¹ˆï¼Ÿ
- å¦‚ä½•å®šä¹‰ä¸€ä¸ª struct?
- å¦‚ä½•å®žä¾‹åŒ– struct?
- struct å­—æ®µçš„ç®€åŒ–å†™æ³•
- ç»“æž„ä½“æ›´æ–°è¯­æ³•
- å…ƒç»„ç»“æž„ä½“
- ç±»å•å…ƒç»“æž„ä½“
- **ç»“æž„ä½“æ•°æ®çš„æ‰€æœ‰æƒ**

ç»“æž„ä½“æ˜¯è‡ªå®šä¹‰æ•°æ®ç±»åž‹ã€‚

```rust
// å®šä¹‰ç»“æž„ä½“
struct User {
    username: String,
    email: String,
    active: bool,
    sign_in_account: u64,
}
// å®žä¾‹åŒ–
let user = User {
    username: String::from("simon"),
    email: String::from("simon@gmail.com"),
    active: true,
    sign_in_account: 1,
}
// ç®€åŒ–ï¼šä¸Ž field ç›¸åŒçš„åå­—
fn build_user(username: String, email: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_account: 1,
    }
}
// æ›´æ–°è¯­æ³•åˆ›å»ºå®žä¾‹
let user2 = User {
    active: false,
    ..user // å¿…é¡»æ”¾åœ¨æœ€åŽ
};
// åˆ›å»º user2 åŽä¸èƒ½å†ä½¿ç”¨ userï¼Œå› ä¸º user çš„ username å’Œ email è¢«ç§»åŠ¨åˆ° user2 ä¸­ã€‚æ‰€æœ‰æƒè¢« move äº†
// å…ƒç¥–ç»“æž„ä½“
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
// ç±»å•å…ƒç»“æž„ä½“: å®žçŽ° trait
struct AlwaysEqual;

// dbg! æŽ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼çš„æ‰€æœ‰æƒï¼ˆprintln!æ˜¯å¼•ç”¨ï¼‰æ‰“å°è°ƒç”¨æ—¶çš„æ–‡ä»¶å’Œè¡Œå·ï¼Œä»¥åŠè¡¨è¾¾å¼ç»“æžœåªï¼Œå¹¶è¿”å›žè¯¥å€¼çš„æ‰€æœ‰æƒ
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```
Rust ä¸å…è®¸å°†ç»“æž„ä½“æŸä¸ªå­—æ®µæ ‡è®°ä¸ºå¯å˜ã€‚

### 5.1 æ–¹æ³•è¯­å¥

æ–¹æ³•ä¸Žå‡½æ•°ï¼š
- method å’Œ function
- éƒ½ä½¿ç”¨ fn + åå­— å£°æ˜Žï¼Œå¯ä»¥æ‹¥æœ‰å‚æ•°å’Œè¿”å›žå€¼
- æ–¹æ³•å®šä¹‰åœ¨ `ç»“æž„ä½“` ä¸Šä¸‹æ–‡ä¸­ï¼ˆstruct,enum,trait)
- æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯ `self`ï¼Œä»£è¡¨è°ƒç”¨æ–¹æ³•çš„ç»“æž„ä½“å®žä¾‹

æ–¹æ³•å®šä¹‰ï¼š

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
// impl ä¸­æ‰€æœ‰å†…å®¹éƒ½ä¸Ž Rectangle å…³è”
impl Rectangle {
    // &self -> rectangle: &Rectangle
    fn area(&self) -> u32 {
        self.width * self.height
    }
    // associated functions
    // æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸ä»¥ self ä¸ºç¬¬ä¸€å‚æ•°çš„å…³è”å‡½æ•°ï¼ˆå› æ­¤ä¸æ˜¯æ–¹æ³•ï¼‰
    fn say_hello() {
        println!("hello");
    }
    // å…³è”å‡½æ•° ç»å¸¸ è¢«ç”¨ä½œè¿”å›žä¸€ä¸ªç»“æž„ä½“æ–°å®žä¾‹çš„æž„é€ å‡½æ•°
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
// æ¯ä¸ªç»“æž„ä½“éƒ½å…è®¸æ‹¥æœ‰å¤šä¸ª impl å—
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        // automatic referencing and dereferencing
        // (&rect1).area()
        rect1.area()
    );
}
```