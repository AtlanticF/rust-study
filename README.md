Study rust from [trpl](https://kaisery.github.io/trpl-zh-cn/)

- ç¼–è¯‘ï¼šrustc
- åŒ…ç®¡ç†ï¼šcargo build / run / new / update
    - Cargo.xml: dependences (SemVer) è¯­ä¹‰åŒ–ç‰ˆæœ¬å·
    - Cargo.lock: æ„å»ºå¯é‡ç°

## ä¸€ã€ä¸€äº›æ¦‚å¿µ

### 1.1 å˜é‡

- ä½¿ç”¨ let ç”³æ˜
- å˜é‡é»˜è®¤æ˜¯ immutableï¼ˆä¸å¯å˜ï¼‰çš„
- ä½¿ç”¨ let mut ç”³æ˜å¯å˜å˜é‡

### 1.2 å¸¸é‡

- ä½¿ç”¨ const ç”³æ˜
- å¸¸é‡æ€»æ˜¯ä¸èƒ½å˜
- å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸä¸­ç”³æ˜ï¼ŒåŒ…æ‹¬å…¨å±€
- çº¦å®šæ˜¯åœ¨å•è¯ä¹‹é—´ä½¿ç”¨å…¨å¤§å†™åŠ ä¸‹åˆ’çº¿
- ç¼–è¯‘æ—¶è®¡ç®—
- åœ¨ç”³æ˜çš„ä½œç”¨åŸŸä¸­ï¼Œå¸¸é‡åœ¨æ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸä¸­éƒ½æœ‰æ•ˆ

### 1.3 éšè—ï¼ˆshadowingï¼‰

- å®šä¹‰ä¸€ä¸ªä¸ä¹‹å‰å˜é‡åŒåçš„æ–°å˜é‡çš„è¡Œä¸ºï¼Œç§°ä¸º shadowing
- mut ä¸ shadowing æœ‰åŒºåˆ«
    - ä¸ä½¿ç”¨ let å¯¹ **ä¸å¯å˜** å˜é‡è¿›è¡Œé‡æ–°èµ‹å€¼æ—¶ä¼šæŠ¥é”™
    - shadowing å®é™…åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå¯ä»¥æ”¹å˜ **å€¼** ç±»å‹ï¼Œå¹¶ä¸”å¤ç”¨è¿™ä¸ªåå­—

### 1.4 æ•°æ®ç±»å‹

#### 1.4.1 æ ‡é‡ scaler: å•ç‹¬çš„å€¼

- æ•´å‹
    - é»˜è®¤ i32
    - 8ï¼Œ16ï¼Œ32ï¼Œ64ï¼Œ128 bit æœ‰æ— ç¬¦å·
    - arch æœ‰æ— ç¬¦å·: isize usizeï¼Œä¾èµ– CPU æ¶æ„
    - å…è®¸ `_` åˆ†éš”ç¬¦: 1_000 = 1000
    - integer overflow
        - åœ¨ debug æ„å»ºä¸­äº§ç”Ÿ panic
        - åœ¨ release æ„å»ºä¸­å‘ç”Ÿ warpping æ“ä½œ
- æµ®ç‚¹å‹
    - f32, f64 ä½¿ç”¨ IEEE-754 æ ‡å‡†è¡¨ç¤º
    - é»˜è®¤ f64
- å¸ƒå°”
    - true, false
- å­—ç¬¦
    - å•å¼•å·
    - å 4å­—èŠ‚
    - ä»£è¡¨ä¸€ä¸ª Unicode æ ‡é‡å€¼

#### 1.4.2 å¤åˆ compound: å¤šä¸ªå€¼ç»„åˆ

- å…ƒç»„ tuple
    - let tup = (100, 2.0, 1) / let tup: (i32, u32, f64) = (-2, 1, 2.3)
    - å£°æ˜åé•¿åº¦ä¸å˜
    - å„å…ƒç´ ç±»å‹å¯ä»¥ä¸åŒ
    - let (x, y, z) = tup ç§°ä¹‹ä¸º destructure
    - é€šè¿‡ `.` è®¿é—®å…ƒç´ 
- æ•°ç»„ array
    - [] ç”³æ˜
    - æ•°ç»„å†…å„å…ƒç´ ç±»å‹å¿…é¡»ç›¸åŒ
    - ä¸å¯å˜é•¿åº¦
    - let a: [i32; 5] = [1, 2, 3, 4, 5]
    - let a = [3; 5] é•¿åº¦ä¸º 5 çš„æ•°ç»„ï¼Œå…ƒç´ éƒ½ä¸º 3
    - a[index] è®¿é—®
    - index out of boundsï¼šè¿è¡Œæ—¶é”™è¯¯ï¼Œpanic

### 1.5 å‡½æ•°

`snake case` è§„èŒƒé£æ ¼ï¼Œå°å†™åŠ ä¸‹åˆ’çº¿åˆ†éš”å•è¯

#### 1.5.1 å‚æ•°

- parameter å’Œ argument

#### 1.5.2 è¯­å¥å’Œè¡¨è¾¾å¼

- å‡½æ•°ä½“ = è¯­å¥ + å¯é€‰çš„ç»“æŸè¡¨è¾¾å¼
- Rust æ˜¯ expression-based è¯­è¨€
- Statements æ‰§è¡Œæ“ä½œï¼Œä¸è¿”å›å€¼çš„ æŒ‡ä»¤
- Expression è®¡ç®—å¹¶äº§ç”Ÿä¸€ä¸ªå€¼ 
- è¡¨è¾¾å¼å¯ä»¥æ˜¯è¯­å¥çš„ä¸€éƒ¨åˆ†: let x = 6
- å‡½æ•°éšå¼è¿”å›æœ€åçš„ **è¡¨è¾¾å¼**

#### 1.5.3 æ³¨é‡Š

- `//`

#### 1.5.4 æ§åˆ¶æµ

- åˆ¤æ–­ **è¡¨è¾¾å¼**: if
- if (expression) expression å¿…é¡»ä¸º bool
- å› ä¸ºæ˜¯è¡¨è¾¾å¼ï¼Œæ‰€ä»¥å…·æœ‰è¿”å›å€¼: let number = if condition {1} else {2};
- åˆ†æ”¯è¡¨è¾¾å¼è¿”å›å€¼ç±»å‹å¿…é¡»ç›¸åŒ

- loop
- å¾ªç¯æ ‡ç­¾ 'counting_up: loop {} -- æ¶ˆé™¤å¤šä¸ªå¾ªç¯ä¹‹é—´çš„æ­§ä¹‰
- while æ¡ä»¶å¾ªç¯
- for éå†é›†åˆ for element in a {}
- for number in (1..4).rev() {}

## äºŒã€æ‰€æœ‰æƒï¼ˆOwnershipï¼‰

å˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼ï¼šå°†å€¼èµ‹ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ç§»åŠ¨å®ƒã€‚å½“æŒæœ‰å †ä¸­æ•°æ®å€¼çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå…¶å€¼å°†é€šè¿‡ drop è¢«æ¸…ç†æ‰ï¼Œé™¤éæ•°æ®è¢«ç§»åŠ¨ä¸ºå¦ä¸€ä¸ªå˜é‡æ‰€æœ‰ã€‚

å®˜æ–¹çš„è¯´æ³•ï¼šæ²¡æœ‰ GCï¼Œæ— éœ€æ‰‹åŠ¨åˆ†é…å’Œé‡Šæ”¾ã€‚ä¾èµ– ownership ç³»ç»Ÿç®¡ç†ï¼Œ`wonership ä»»ä½•åŠŸèƒ½éƒ½ä¸ä¼šå‡æ…¢ç¨‹åº`ã€‚è·Ÿè¸ªä»£ç æ­£åœ¨ä½¿ç”¨çš„ `å †` ä¸Šçš„æ•°æ®ï¼Œæœ€å¤§é™åº¦å‡å°‘å †ä¸Š `é‡å¤` æ•°æ®çš„é‡ï¼Œå¹¶ä¸”æ¸…ç†å †ä¸Šä¸å†ä½¿ç”¨çš„æ•°æ®ã€‚

ownership æ˜¯ rust å†…å­˜ç®¡ç†çš„ä¸€ç§å®ç°ã€‚åŒºåˆ«äº GC å’Œæ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œownership ä¸ºæ¯å—è¢«åˆ†é…çš„å†…å­˜å®šä¹‰äº†ä½œç”¨åŸŸå’Œæ‰€æœ‰è€…ï¼Œ`(å †ä¸Š)å†…å­˜åœ¨æ‹¥æœ‰å®ƒçš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸåå°±è¢«è‡ªåŠ¨é‡Šæ”¾`

ç†è§£ï¼š`heap ä¸Šåˆ†é…çš„å†…å­˜`æŒ‡å‘çš„å˜é‡ï¼Œrust ä¼šä½¿ç”¨ `ownership` ç®¡ç†èµ·æ¥ï¼Œå½“å˜é‡`ç¦»å¼€ä½œç”¨åŸŸ`æ—¶ï¼Œè°ƒç”¨ `drop` è‡ªåŠ¨æ¸…ç†å˜é‡çš„å †å†…å­˜ã€‚

å…³äºäºŒæ¬¡é‡Šæ”¾ï¼ˆdouble freeï¼‰ï¼š
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    // stack ä¸Š s1 æ ‡è®°ä¸ºæ— æ•ˆï¼Œæ­¤æ—¶æ— æ³•ä½¿ç”¨ s1
    // ä¹Ÿå¯ä»¥ç†è§£ä¸º s1 çš„ ownership move åˆ° s2 äº†

    println!("{}, world!", s1);
}
```
 
### 2.1 ä¸‰ä¸ªè§„åˆ™

- Rust ä¸­æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ª **æ‰€æœ‰è€…ï¼ˆOwnerï¼‰**
- å€¼åœ¨ä»»ä½•æ—¶åˆ»éƒ½åªæœ‰ **ä¸€ä¸ª** æ‰€æœ‰è€…
- å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼è¢«æŠ›å¼ƒ

### 2.2 å˜é‡ä½œç”¨åŸŸ

å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼ŒRust ä¸ºæˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å«åš drop

### 2.3 ç§»åŠ¨

```rust
let x = 5;
let y = x;

let s1 = String::from("hello");
let s2 = s1;
```
![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-01.svg)
![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-02.svg)
![move](https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg)

### 2.4 å…‹éš†

éœ€æ±‚ï¼šéœ€è¦æ·±åº¦å¤åˆ¶æŸå˜é‡å †ä¸Šæ•°æ®

ä½¿ç”¨ï¼š
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    // æ­¤æ—¶ s1ï¼Œs2 å‡æœ‰æ•ˆï¼Œs1 ownership å¹¶æ²¡æœ‰ move
    // å †ä¸Šç”³è¯·äº†ä¸¤ä»½å†…å­˜ï¼Œå­˜å‚¨ "hello"
    println!("s1 = {}, s2 = {}", s1, s2);
}
```

### 2.5 Copy

åƒæ•´å‹è¿™æ ·çš„åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°çš„ç±»å‹è¢«æ•´ä¸ªå­˜å‚¨åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥æ‹·è´å…¶å®é™…çš„å€¼æ˜¯å¿«é€Ÿçš„ã€‚

å®ç°ï¼š`Copy trait` æ³¨è§£ã€‚ä»»ä½•ä¸€ç»„ç®€å•æ ‡é‡å€¼çš„ç»„åˆéƒ½å¯ä»¥å®ç° Copyã€‚

### 2.6 æ‰€æœ‰æƒå’Œå‡½æ•°

```rust
fn main() {
    let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ

    takes_ownership(s);             // s çš„ å€¼ ç§»åŠ¨åˆ°å‡½æ•°é‡Œï¼Œs å¤±æ•ˆï¼Œsome_string æœ‰æ•ˆ
                                    // some_string = s
                                    // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ

    let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ

    makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                    // ä½† i32 æ˜¯ Copy çš„ï¼Œ
                                    // æ‰€ä»¥åœ¨åé¢å¯ç»§ç»­ä½¿ç”¨ x

} // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
  // æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
} // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚
  // å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
} // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„
```

### 2.6 æ‰€æœ‰æƒå’Œä½œç”¨åŸŸ

è¿”å›å€¼ä¹Ÿå¯ä»¥è½¬ç§»æ‰€æœ‰æƒã€‚

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership å°†è¿”å›å€¼
                                        // è½¬ç§»ç»™ s1

    let s2 = String::from("hello");     // s2 è¿›å…¥ä½œç”¨åŸŸ

    let s3 = takes_and_gives_back(s2);  // s2 è¢«ç§»åŠ¨åˆ°
                                        // takes_and_gives_back ä¸­,
                                        // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
} // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {             // gives_ownership ä¼šå°†
                                             // è¿”å›å€¼ç§»åŠ¨ç»™
                                             // è°ƒç”¨å®ƒçš„å‡½æ•°

    let some_string = String::from("yours"); // some_string è¿›å…¥ä½œç”¨åŸŸ.

    some_string                              // è¿”å› some_string 
                                             // å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}

// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ
    a_string  // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}
```
é—®é¢˜ï¼šç»§ç»­ä½¿ç”¨æ‰€æœ‰æƒè½¬ç§»å‰çš„å‚æ•°æ˜¯å¸¸è§çš„éœ€æ±‚ï¼Œæ¯æ¬¡è½¬ç§»å†è¿”å›ç•¥æ˜¾å•°å—¦ï¼Œå¦‚æœä½¿ç”¨ä½¿ç”¨ tuple ä¹Ÿæ˜¯å¤æ‚ï¼Œå¦‚ä½•æ›´ä¼˜é›…åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ
Rust æå‡º **borrowing** å’Œ **references**

## ä¸‰ã€å¼•ç”¨å’Œå€Ÿç”¨

### 3.1 æ¦‚å¿µ

å¼•ç”¨ï¼ˆreferenceï¼‰åƒä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæ˜¯ä¸€ä¸ªåœ°å€ï¼Œå¯ä»¥ç”±æ­¤è®¿é—®å‚¨å­˜äºè¯¥åœ°å€çš„å±äºå…¶ä»–å˜é‡çš„æ•°æ®ã€‚å…è®¸ä½ ä½¿ç”¨å€¼ä½†ä¸è·å–å…¶æ‰€æœ‰æƒã€‚

ç†è§£ï¼šçŒœæµ‹å®ç°ï¼Œrust å»ºç«‹å¼•ç”¨ï¼Œä½†æ˜¯å¹¶ä¸ä¼šå°†å¼•ç”¨ä¸å€¼åšç»‘å®šï¼ˆèµ‹äºˆå¼•ç”¨å€¼çš„æ‰€æœ‰æƒï¼‰ï¼Œæ‰€ä»¥å¼•ç”¨åœ¨ç¦»å¼€å…¶ä½œç”¨åŸŸçš„æ—¶å€™ä¹Ÿä¸ä¼šè¿›è¡Œ drop

åˆ›å»ºä¸€ä¸ªå¼•ç”¨çš„è¡Œä¸ºï¼š**å€Ÿç”¨ï¼ˆborrowingï¼‰**
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
// è¿™é‡Œï¼Œs ç¦»å¼€äº†ä½œç”¨åŸŸã€‚ä½†å› ä¸ºå®ƒå¹¶ä¸æ‹¥æœ‰å¼•ç”¨å€¼çš„æ‰€æœ‰æƒï¼Œ
// æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿï¼ˆå¼•ç”¨ç¦»å¼€ä½œç”¨åŸŸä¸ä¼š dropï¼Œå› ä¸ºä¸å…·æœ‰æ‰€æœ‰æƒï¼‰
```
![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-05.svg)

`æ­£å¦‚å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå¼•ç”¨ä¹Ÿä¸€æ ·ã€‚ï¼ˆé»˜è®¤ï¼‰ä¸å…è®¸ä¿®æ”¹å¼•ç”¨çš„å€¼ã€‚å€Ÿçš„ä¸œè¥¿ä¸èƒ½éšæ„æ”¹å˜ï¼Œè¿™é‡Œç†æ‰€å½“ç„¶çš„ã€‚`

ğŸ¤” æ€è€ƒï¼šé€šè¿‡ä¼ é€’å¯å˜çš„å¼•ç”¨æ˜¯å¦å¯ä»¥ä¿®æ”¹ä¸å¯è¾¨çš„å˜é‡ï¼ŸNo: ä¸å¯å˜å˜é‡å°±æ˜¯ä¸å¯å˜

### 3.2 å¯å˜å¼•ç”¨

å¯å˜å¼•ç”¨çš„é™åˆ¶ï¼šå¦‚æœä½ æœ‰ä¸€ä¸ªå¯¹è¯¥å˜é‡çš„**å¯å˜å¼•ç”¨**ï¼Œ**åœ¨åŒä¸€ä½œç”¨åŸŸ**ï¼Œä½ å°±ä¸èƒ½å†åˆ›å»ºå¯¹è¯¥å˜é‡çš„**å¼•ç”¨**ã€‚

è®¾è®¡ç›®çš„ï¼šé¿å… data race æ•°æ®ç«äº‰å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚é˜²æ­¢åŒä¸€æ—¶é—´å¯¹åŒä¸€æ•°æ®å­˜åœ¨å¤šä¸ªå¯å˜å¼•ç”¨ã€‚

é€ æˆ data race åŸå› ï¼š
- ä¸¤ä¸ªæˆ–å¤šä¸ªæŒ‡é’ˆ`åŒæ—¶`è®¿é—®åŒä¸€æ•°æ®
- è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆè¢«ç”¨æ¥å†™æ•°æ®
- æ²¡æœ‰åŒæ­¥æ•°æ®è®¿é—®çš„æœºåˆ¶

å¤šä¸ªä¸å¯å˜å¼•ç”¨æ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºæ²¡æœ‰å“ªä¸ªåªèƒ½è¯»å–æ•°æ®çš„äººæœ‰èƒ½åŠ›å½±å“å…¶ä»–äººè¯»å–åˆ°çš„æ•°æ®ã€‚

å¼•ç”¨çš„ä½œç”¨åŸŸä»å£°æ˜çš„åœ°æ–¹å¼€å§‹ä¸€ç›´æŒç»­åˆ°æœ€åä¸€æ¬¡ä½¿ç”¨ä¸ºæ­¢ã€‚ç¼–è¯‘å™¨åœ¨ä½œç”¨åŸŸç»“æŸä¹‹å‰åˆ¤æ–­ä¸å†ä½¿ç”¨çš„å¼•ç”¨çš„èƒ½åŠ›è¢«ç§°ä¸º **éè¯æ³•ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸ**ï¼ˆNon-Lexical Lifetimesï¼Œç®€ç§° NLLï¼‰ã€‚

```rust
fn main() {
    // å¯å˜å˜é‡
    let mut s = String::from("hello");
    // å¢åŠ  mut -> åˆ›å»ºå¯å˜å¼•ç”¨ s
    change(&mut s);
}

fn change(some_string: &mut String) {
    // æ”¹å˜å¼•ç”¨ somg_string æŒ‡å‘çš„å†…å­˜çš„å€¼
    some_string.push_str(", world");
}
```

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // æ²¡é—®é¢˜
    let r2 = &s; // æ²¡é—®é¢˜
    println!("{} and {}", r1, r2);
    // æ­¤ä½ç½®ä¹‹å r1 å’Œ r2 ä¸å†ä½¿ç”¨ï¼ˆåç»­ä»£ç ä¸­æ²¡æœ‰ r1 å’Œ r2ï¼Ÿï¼‰

    let r3 = &mut s; // æ²¡é—®é¢˜
    println!("{}", r3);
}
```

### 3.3 å‚æ‚¬å¼•ç”¨

æ‚¬å‚æŒ‡é’ˆï¼šå…¶æŒ‡å‘çš„å†…å­˜å¯èƒ½å·²ç»è¢«åˆ†é…ç»™å…¶å®ƒæŒæœ‰è€…ã€‚
åœ¨ Rust ä¸­ç¼–è¯‘å™¨ç¡®ä¿å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šå˜æˆæ‚¬å‚çŠ¶æ€ï¼šå½“ä½ æ‹¥æœ‰ä¸€äº›æ•°æ®çš„å¼•ç”¨ï¼Œç¼–è¯‘å™¨ç¡®ä¿æ•°æ®ä¸ä¼šåœ¨å…¶å¼•ç”¨ä¹‹å‰ç¦»å¼€ä½œç”¨åŸŸã€‚

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    // s åˆ›å»º
    let s = String::from("hello");
    // å°è¯•è¿”å› s çš„å¼•ç”¨
    &s
} // s ç¦»å¼€ä½œç”¨åŸŸï¼Œdrop è°ƒç”¨ï¼Œå†…å­˜é‡Šæ”¾ï¼Œæ­¤æ—¶ &s å‚æ‚¬
```

### 3.4 å¼•ç”¨è§„åˆ™

- åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼ˆä½œç”¨åŸŸï¼‰ï¼Œè¦ä¹ˆ åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆ åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚
- å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚ï¼ˆç¼–è¯‘å™¨ä¿è¯æ²¡æœ‰å‚æ‚¬å¼•ç”¨ï¼‰ã€‚

## å››ã€Slice ç±»å‹

Slice å…è®¸å¼•ç”¨é›†åˆä¸­ä¸€æ®µ`è¿ç»­çš„`å…ƒç´ åºåˆ—ã€‚slice æ˜¯ä¸€ç±»å¼•ç”¨ï¼Œ`æ²¡æœ‰æ‰€æœ‰æƒ`ã€‚

é—®é¢˜ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªç”¨ç©ºæ ¼åˆ†éš”å•è¯çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›åœ¨è¯¥å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªå•è¯ã€‚å¦‚æœå‡½æ•°åœ¨è¯¥å­—ç¬¦ä¸²ä¸­å¹¶æœªæ‰¾åˆ°ç©ºæ ¼ï¼Œåˆ™æ•´ä¸ªå­—ç¬¦ä¸²å°±æ˜¯ä¸€ä¸ªå•è¯ï¼Œæ‰€ä»¥åº”è¯¥è¿”å›æ•´ä¸ªå­—ç¬¦ä¸²ã€‚

```rust
fn first_word_idx(s: &String) -> usize {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    s.len()
}
fn main() {
    let mut s = String::from("helo world");
    let word = first_word_index(&s);
    s.clear();
    // word å€¼ä»ç„¶æ˜¯ 5
    // å› ä¸º s æ— æ•ˆäº†ï¼Œæ­¤å¤„ 5 ä¹Ÿæ²¡æœ‰æ„ä¹‰äº†
}
```

### 4.1 å­—ç¬¦ä¸² slice

```rust
let s = String::from("hello world");
// [0,5) [6,11)
// len = end - start
let hello = &s[0..5]; // hello -> reference -> 'hello'
let world = &s[6..11]; // world -> reference -> 'world'
```

    æ³¨æ„ï¼šå­—ç¬¦ä¸² slice range çš„ç´¢å¼•å¿…é¡»ä½äºæœ‰æ•ˆçš„ UTF-8 å­—ç¬¦è¾¹ç•Œå†…ï¼Œå¦‚æœå°è¯•ä»å­—æ¥å­—ç¬¦çš„ä¸­é—´ä½ç½®åˆ›å»ºå­—ç¬¦ä¸² sliceï¼Œåˆ™ç¨‹åºå°†ä¼šå› é”™è¯¯è€Œé€€å‡ºã€‚ï¼ˆç†è§£ï¼šslice range æ˜¯å•å­—èŠ‚çš„ï¼‰

```rust
// string slice range å•å­—èŠ‚

let s = String::from("ä¸­"); // hex:E4B8AD -> 3bytes
let c = &s[0..1];
println!("ä¸­ slice[0..1] is {}", c);
```

String variable, String reference, String reference å¯¹æ¯”ï¼š

- String variable: {ptr, len, capacity}
- String reference: {ptr}
- String slice: {ptr, len}

```rust
// &str ä»£è¡¨ string slice
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}
fn main() {
    let mut s = String::from("hello world");
    // è·å–äº† s çš„ä¸å¯å˜å¼•ç”¨ -> world
    let world = first_word(&s);
    s.clear(); // æ¸…ç©ºä¼šå°è¯•è·å–ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œç¼–è¯‘é”™è¯¯
    // è¿˜è¦ä½¿ç”¨ worldï¼Œæ ¹æ® NLL æ­¤æ—¶ world ä¸å¯å˜å¼•ç”¨ä¾ç„¶æœ‰æ•ˆ
    println!("the first world is: {}", world);
}
```

### 4.2 å­—ç¬¦ä¸²çš„å­—é¢å€¼å°±æ˜¯ slice

```rust
let s = "Hello world";
```

ä¸ºä»€ä¹ˆå­—ç¬¦ä¸²å­—é¢å€¼ä¸å¯å˜ï¼Ÿå› ä¸ºæ˜¯ &str ç±»å‹ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ã€‚


### 4.3 å­—ç¬¦ä¸² slice ä½œå‚æ•°

```rust
// deref coercions
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}

fn main() {
    let my_string = String::from("hello world");

    // `first_word` é€‚ç”¨äº `String`ï¼ˆçš„ sliceï¼‰ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` ä¹Ÿé€‚ç”¨äº `String` çš„å¼•ç”¨ï¼Œ
    // è¿™ç­‰ä»·äºæ•´ä¸ª `String` çš„ slice
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` é€‚ç”¨äºå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // å› ä¸ºå­—ç¬¦ä¸²å­—é¢å€¼å·²ç» **æ˜¯** å­—ç¬¦ä¸² slice äº†ï¼Œ
    // è¿™ä¹Ÿæ˜¯é€‚ç”¨çš„ï¼Œæ— éœ€ slice è¯­æ³•ï¼
    let word = first_word(my_string_literal);
}
```

### 4.4 å…¶ä»–ç±»å‹çš„ slice

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let slice = &a[1..3];

    assert_eq!(slice, &[2, 3]);
}
```

## äº”ã€ç»“æ„ä½“ Struct

- structure æ˜¯ä»€ä¹ˆï¼Ÿ
- å¦‚ä½•å®šä¹‰ä¸€ä¸ª struct?
- å¦‚ä½•å®ä¾‹åŒ– struct?
- struct å­—æ®µçš„ç®€åŒ–å†™æ³•
- ç»“æ„ä½“æ›´æ–°è¯­æ³•
- å…ƒç»„ç»“æ„ä½“
- ç±»å•å…ƒç»“æ„ä½“
- **ç»“æ„ä½“æ•°æ®çš„æ‰€æœ‰æƒ**

ç»“æ„ä½“æ˜¯è‡ªå®šä¹‰æ•°æ®ç±»å‹ã€‚

```rust
// å®šä¹‰ç»“æ„ä½“
struct User {
    username: String,
    email: String,
    active: bool,
    sign_in_account: u64,
}
// å®ä¾‹åŒ–
let user = User {
    username: String::from("simon"),
    email: String::from("simon@gmail.com"),
    active: true,
    sign_in_account: 1,
}
// ç®€åŒ–ï¼šä¸ field ç›¸åŒçš„åå­—
fn build_user(username: String, email: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_account: 1,
    }
}
// æ›´æ–°è¯­æ³•åˆ›å»ºå®ä¾‹
let user2 = User {
    active: false,
    ..user // å¿…é¡»æ”¾åœ¨æœ€å
};
// åˆ›å»º user2 åä¸èƒ½å†ä½¿ç”¨ userï¼Œå› ä¸º user çš„ username å’Œ email è¢«ç§»åŠ¨åˆ° user2 ä¸­ã€‚æ‰€æœ‰æƒè¢« move äº†
// å…ƒç¥–ç»“æ„ä½“
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
// ç±»å•å…ƒç»“æ„ä½“: å®ç° trait
struct AlwaysEqual;

// dbg! æ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼çš„æ‰€æœ‰æƒï¼ˆprintln!æ˜¯å¼•ç”¨ï¼‰æ‰“å°è°ƒç”¨æ—¶çš„æ–‡ä»¶å’Œè¡Œå·ï¼Œä»¥åŠè¡¨è¾¾å¼ç»“æœåªï¼Œå¹¶è¿”å›è¯¥å€¼çš„æ‰€æœ‰æƒ
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```
Rust ä¸å…è®¸å°†ç»“æ„ä½“æŸä¸ªå­—æ®µæ ‡è®°ä¸ºå¯å˜ã€‚

### 5.1 æ–¹æ³•è¯­å¥

æ–¹æ³•ä¸å‡½æ•°ï¼š
- method å’Œ function
- éƒ½ä½¿ç”¨ fn + åå­— å£°æ˜ï¼Œå¯ä»¥æ‹¥æœ‰å‚æ•°å’Œè¿”å›å€¼
- æ–¹æ³•å®šä¹‰åœ¨ `ç»“æ„ä½“` ä¸Šä¸‹æ–‡ä¸­ï¼ˆstruct,enum,trait)
- æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯ `self`ï¼Œä»£è¡¨è°ƒç”¨æ–¹æ³•çš„ç»“æ„ä½“å®ä¾‹

æ–¹æ³•å®šä¹‰ï¼š

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
// impl ä¸­æ‰€æœ‰å†…å®¹éƒ½ä¸ Rectangle å…³è”
impl Rectangle {
    // &self -> rectangle: &Rectangle
    fn area(&self) -> u32 {
        self.width * self.height
    }
    // associated functions
    // æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸ä»¥ self ä¸ºç¬¬ä¸€å‚æ•°çš„å…³è”å‡½æ•°ï¼ˆå› æ­¤ä¸æ˜¯æ–¹æ³•ï¼‰
    fn say_hello() {
        println!("hello");
    }
    // å…³è”å‡½æ•° ç»å¸¸ è¢«ç”¨ä½œè¿”å›ä¸€ä¸ªç»“æ„ä½“æ–°å®ä¾‹çš„æ„é€ å‡½æ•°
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
// æ¯ä¸ªç»“æ„ä½“éƒ½å…è®¸æ‹¥æœ‰å¤šä¸ª impl å—
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        // automatic referencing and dereferencing
        // (&rect1).area()
        rect1.area()
    );
}
```

## å…­ã€æšä¸¾å’Œæ¨¡å¼åŒ¹é…ï¼ˆenumerations and match patternsï¼‰

### 6.1 æšä¸¾çš„å®šä¹‰

æšä¸¾æä¾›æŠŠå€¼æˆä¸ºä¸€ä¸ªé›†åˆä¹‹ä¸€çš„æ–¹æ³•ã€‚

```rust
enum IpAddrKind {
    IPv4,
    IPv6,
}
let ipv4 = IpAddrKind::IPv4;
let ipv6 = IpAddrKink::IPv6;
fn route(ip_kind: IpAddrKind) {}
route(IpAddrKind::IPv4);
route(IpAddrKind::IPv6);

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}
let localhost = IpAddr {
    kind: IpAddrKind::IPv4,
    address: String::from("127.0.0.1"),
};
let loopback = IpAddr {
    kind: IpAddrKind::IPv6,
    address: String::from("::1"),
},

enum IpAddr {
    V4(String), // V4(u8, u8, u8, u8)
    V6(String),
}
let localhost = IpAddr(String::from("127.0.0.1"));
let loopback = IpAddr(String::from("::1"));

// Quit æ²¡æœ‰å…³è”ä»»ä½•æ•°æ®
// Move ç±»ä¼¼ç»“æ„ä½“åŒ…å«å‘½åå­—æ®µ
// Write åŒ…å«å•ç‹¬ä¸€ä¸ª String
// ChangeColor åŒ…å«ä¸‰ä¸ª i32
enum Message {
    Quit,
    Move: {x: i32, y: i32},
    Write(String),
    ChangeColor(i32, i32, i32),
}
// enum ä¾ç„¶å¯ä»¥ä½¿ç”¨ impl æ¥å®šä¹‰æ–¹æ³•
impl Message {
    fn call(&self) {

    }
}
let m = Message::Wirte(String::from("hello"));
m.call();
```

Rustæ²¡æœ‰ç©ºå€¼ï¼Œå­˜åœ¨Noneæ¦‚å¿µæšä¸¾ Option<T>

```rust
enum Option<T> {
    None,
    Some(T),
}
let some_number = Some(5);
let some_char = Some('a');
// å…è®¸ä½¿ç”¨ Option<T> æ¥å®šä¹‰ None å€¼
// å¸Œæœ› absent_number æ˜¯ i32 ç±»å‹ï¼Œä½†æ˜¯ç°åœ¨å®ƒçš„å€¼æ˜¯æšä¸¾ None
let absent_number: Option<i32> = None;
let x: i8 = 5;
let y: Option<i8> = Some(5);
// no implementation for `i8 + Option<i8>`
// ç±»å‹ä¸åŒï¼Œæ— æ³•ç›¸åŠ 
// åœ¨å¯¹ Option<T> è¿›è¡Œ T çš„è¿ç®—ä¹‹å‰å¿…é¡»å°†å…¶è½¬æ¢ä¸º Tã€‚é€šå¸¸è¿™èƒ½å¸®åŠ©æˆ‘ä»¬æ•è·åˆ°ç©ºå€¼æœ€å¸¸è§çš„é—®é¢˜ä¹‹ä¸€ï¼šå‡è®¾æŸå€¼ä¸ä¸ºç©ºä½†å®é™…ä¸Šä¸ºç©ºçš„æƒ…å†µã€‚
// åªæœ‰å½“ä½¿ç”¨ Option<i8>ï¼ˆæˆ–è€…ä»»ä½•ç”¨åˆ°çš„ç±»å‹ï¼‰çš„æ—¶å€™éœ€è¦æ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µã€‚
let sum = x + y;
```

### 6.2 match æ¨¡å¼åŒ¹é…æ§åˆ¶æµç»“æ„

match æ§åˆ¶æµè¿ç®—ç¬¦å…è®¸æˆ‘ä»¬å°†ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¹¶æ ¹æ®åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œç›¸åº”çš„ä»£ç ï¼ˆæœ‰ç‚¹åƒ switch caseï¼‰

```rust
enum Mac {
    BookPro,
    BookAir,
    IMac,
}
fn value_in_mac(mac: Mac) -> u32 {
    match mac {
        Mac::BookPro => 9999,
        Mac::BookAir => 7999,
        Mac::IMac => 12999,
    }
}
// é€šå¸¸åˆ†æ”¯ä»£ç æ¯”è¾ƒçŸ­ä¸ä½¿ç”¨å¤§æ‹¬å·
// å¤šè¡Œä»£ç å¯ä»¥ä½¿ç”¨å¤§æ‹¬å·ï¼Œåˆ†æ”¯åçš„é€—å·æ˜¯å¯é€‰çš„


// é€šè¿‡æšä¸¾æˆå‘˜ç»‘å®šå€¼
#[derive(Debug)]
enum Country {
    China,
    America,
    India,
    Japanese,
    Korean,
}
// macbookpro åœ¨ä¸åŒå›½å®¶çš„ç‰ˆæœ¬ä¸åŒ
enum Mac {
    BookPro(Country),
    BookAir,
    IMac,
}
fn value_in_mac(mac: Mac) -> u32 {
    match mac {
        Mac::BookPro(country) => {
            println!("Country from {:?} version.", country);
            9999
        },
        Mac::BoorAir => 7999,
        Mac::IMac => 12999,
    }
}
// call
value_in_mac(Mac::BookPro(Country::China));
```

#### Option<T> åŒ¹é…

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```

match åŒ¹é…æ˜¯ç©·å°½çš„ï¼ˆæœ‰é™çš„ï¼‰ï¼šå¿…é¡»ç©·ä¸¾åˆ°æœ€åçš„å¯èƒ½æ€§æ¥ä½¿ä»£ç æœ‰æ•ˆ

#### é€šé…æ¨¡å¼å’Œ _ å ä½ç¬¦

å¦‚æœå¸Œæœ›å¯¹ä¸€äº›ç‰¹å®šçš„å€¼é‡‡ç”¨ç‰¹æ®Šæ“ä½œï¼Œå¯¹å…¶ä»–çš„å€¼é‡‡ç”¨é»˜è®¤æ“ä½œã€‚

```rust
let dice_roll = 9;
match dice_roll {
    3 => have_a_drink(),
    6 => take_a_photo(),
    // other é€šé…
    // å³ä½¿æˆ‘ä»¬æ²¡æœ‰åˆ—å‡º u8 æ‰€æœ‰å¯èƒ½çš„å€¼ï¼Œè¿™æ®µä»£ç ä¾ç„¶èƒ½å¤Ÿç¼–è¯‘ï¼Œå› ä¸ºæœ€åä¸€ä¸ªæ¨¡å¼å°†åŒ¹é…æ‰€æœ‰æœªè¢«ç‰¹æ®Šåˆ—å‡ºçš„å€¼
    // æˆ‘ä»¬å¿…é¡»å°†é€šé…åˆ†æ”¯æ”¾åœ¨æœ€å
    // å¦‚æœæˆ‘ä»¬åœ¨é€šé…åˆ†æ”¯åæ·»åŠ å…¶ä»–åˆ†æ”¯ï¼ŒRust å°†ä¼šè­¦å‘Šæˆ‘ä»¬ï¼Œå› ä¸ºæ­¤åçš„åˆ†æ”¯æ°¸è¿œä¸ä¼šè¢«åŒ¹é…åˆ°
    other => move_player(other),
}
fn have_a_drink() {}
fn take_a_photo() {}
fn move_player(other: u8) {}

fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => assassinate(),
        7 => guard(),
        // æ— äº‹å‘ç”Ÿï¼Œä¸åšä»»ä½•æ“ä½œ
        _ => (),
    }
    fn assassinate() {}
    fn guard() {}
}
```

### 6.3 if let ç®€æ´æ§åˆ¶

ç®€åŒ–å†—é•¿çš„ match æ¨¡å¼åŒ¹é…ã€‚
è¿™æ ·ä¼šå¤±å» match å¼ºåˆ¶è¦æ±‚çš„ç©·å°½æ€§æ£€æŸ¥ã€‚
match å’Œ if let ä¹‹é—´çš„é€‰æ‹©ä¾èµ–ç‰¹å®šçš„ç¯å¢ƒä»¥åŠå¢åŠ ç®€æ´åº¦å’Œå¤±å»ç©·å°½æ€§æ£€æŸ¥çš„æƒè¡¡å–èˆã€‚

å¯ä»¥è®¤ä¸º if let æ˜¯ match çš„ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒå½“å€¼åŒ¹é…æŸä¸€æ¨¡å¼æ—¶æ‰§è¡Œä»£ç è€Œå¿½ç•¥æ‰€æœ‰å…¶ä»–å€¼ã€‚

```rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("max: " + max),
    _ => (),
}

let config_max_2 = Some(3u8);
if let Some(max) => config_max_2 {
    println!("max: " + max);
}
// å¯ä»¥åœ¨ if let ä¸­åŒ…å«ä¸€ä¸ª elseã€‚else å—ä¸­çš„ä»£ç ä¸ match è¡¨è¾¾å¼ä¸­çš„ _ åˆ†æ”¯å—ä¸­çš„ä»£ç ç›¸åŒ

let mut count = 0;
if let Coin::Quarter(state) => coin {
    println!("count: " + count);
} else {
    count += 1;
}
```

## ä¸ƒã€åŒ…ã€Crateå’Œæ¨¡å—

### 7.1 åŒ…å’Œ crate

`crate æ˜¯ Rust åœ¨ç¼–è¯‘æ—¶æœ€å°çš„ä»£ç å•ä½ï¼Œå³ä¾¿æ˜¯ç”¨ rustc è€Œä¸æ˜¯ cargo æ¥ç¼–è¯‘ä¸€ä¸ªæ–‡ä»¶ï¼Œç¼–è¯‘å™¨è¿˜æ˜¯ä¼šå°†é‚£ä¸ªæ–‡ä»¶è®¤ä½œä¸€ä¸ª crate`

crate ä¸¤ç§å½¢å¼ï¼š
- äºŒè¿›åˆ¶é¡¹
- åº“

package ç»„ç»‡ä¸€ä¸ªæˆ–å¤šä¸ª crateï¼Œpackage ä¸­æœ€å¤šåŒ…æ¶µä¸€ä¸ª library crateï¼Œå¯ä»¥åŒ…å«ä»»æ„å¤šä¸ª binary crateã€‚è‡³å°‘åŒ…å«ä¸€ä¸ª crateã€‚

Cargo éµå¾ªçš„ä¸€ä¸ªçº¦å®šï¼šsrc/main.rs å°±æ˜¯ä¸€ä¸ªä¸åŒ…åŒåçš„äºŒè¿›åˆ¶ crate çš„ crate rootã€‚
åŒæ ·çš„ï¼Œå¦‚æœåŒ…ç›®å½•ä¸­åŒ…å« src/lib.rsï¼Œåˆ™åŒ…å¸¦æœ‰ä¸å…¶åŒåçš„åº“ crateï¼Œä¸” src/lib.rs æ˜¯ crate rootã€‚

crate æ ¹æ–‡ä»¶å°†ç”± Cargo ä¼ é€’ç»™ rustc æ¥å®é™…æ„å»ºåº“æˆ–è€…äºŒè¿›åˆ¶é¡¹ç›®ã€‚
crate å’Œæ¨¡å—ç»“æ„ç»„æˆ module treeã€‚

### 7.2 module æ§åˆ¶ scope å’Œç§æœ‰æ€§

ç¼–è¯‘å™¨ç¼–è¯‘æ¨¡å—çš„å·¥ä½œè¿‡ç¨‹ï¼š

- **å¼€å§‹ï¼š**ä» crate root å¼€å§‹å¯»æ‰¾è¦è¢«ç¼–è¯‘çš„ä»£ç 
- **ç”³æ˜æ¨¡å—ï¼š**åœ¨ crate root ä¸­ç”³æ˜çš„æ¨¡å—ä¼šåœ¨ä»¥ä¸‹è·¯å¾„å¯»æ‰¾ï¼š
    - å†…è”ï¼Œåœ¨å¤§æ‹¬å·ä¸­ï¼Œå½“ mod ${module_name} åæ–¹ä¸æ˜¯ä¸€ä¸ªåˆ†å·è€Œæ˜¯ä¸€ä¸ªå¤§æ‹¬å·
    - æ–‡ä»¶ src/${module_name}.rc
    - æ–‡ä»¶ src/${module_name}/mod.rc
- **ç”³æ˜å­æ¨¡å—ï¼š**åœ¨ crate root å¤–çš„å…¶ä»–æ–‡ä»¶ä¸­ï¼Œå¯ä»¥å®šä¹‰ï¼š
    - å†…è”ï¼Œåœ¨å¤§æ‹¬å·ä¸­ï¼Œå½“ mod ${module_name} åæ–¹ä¸æ˜¯ä¸€ä¸ªåˆ†å·è€Œæ˜¯ä¸€ä¸ªå¤§æ‹¬å·
    - æ–‡ä»¶ src/${parent_module}/${module_name}.rc
    - æ–‡ä»¶ src/${parent_module}/${module_name}/mod.rc
- **æ¨¡å—çš„ä»£ç è·¯å¾„ï¼š**åœ¨éšç§è§„åˆ™å…è®¸çš„å‰æä¸‹ï¼ŒåŒä¸€ crate å†…ä»»æ„åœ°æ–¹å¯ä»¥é€šè¿‡ä»£ç è·¯å¾„å¼•ç”¨è¯¥æ¨¡å—çš„ä»£ç ï¼ˆğŸ¤”ä¸åŒ crate å†…è¦å¼•å…¥åˆ«çš„ crate çš„ä»£ç å‘¢ï¼Ÿ)
- **pub å…³é”®å­—ï¼š**ä¸€ä¸ªæ¨¡å—é‡Œçš„ä»£ç é»˜è®¤å¯¹çˆ¶æ¨¡å—ç§æœ‰ï¼ˆé»˜è®¤çˆ¶æ¨¡å—æ— æ³•å¼•å…¥æ¨¡å—ï¼‰ã€‚ä¸ºäº†ä½¿ä¸€ä¸ªæ¨¡å—å…¬ç”¨ï¼Œåº”å½“åœ¨å£°æ˜æ—¶ä½¿ç”¨pub modæ›¿ä»£modã€‚ä¸ºäº†ä½¿ä¸€ä¸ªå…¬ç”¨æ¨¡å—å†…éƒ¨çš„æˆå‘˜å…¬ç”¨ï¼Œåº”å½“åœ¨å£°æ˜å‰ä½¿ç”¨pubï¼ˆå‡½æ•°/æ–¹æ³•ä¹Ÿæœ‰æœ‰éšç§è§„åˆ™ï¼‰
- **use å…³é”®å­—ï¼š**useå…³é”®å­—åˆ›å»ºäº†ä¸€ä¸ªæˆå‘˜çš„å¿«æ·æ–¹å¼ï¼Œç”¨æ¥å‡å°‘é•¿è·¯å¾„çš„é‡å¤ï¼ˆç±»ä¼¼ PHP useï¼‰

### 7.3 å¼•ç”¨æ¨¡å—

- ç»å¯¹è·¯å¾„ï¼šä» crate æ ¹å¼€å§‹ï¼Œä»¥ crate åå­—æˆ–è€…å­—é¢å€¼ crate å¼€å¤´ã€‚
- ç›¸å¯¹è·¯å¾„ï¼šä»å½“å‰æ¨¡å—å¼€å§‹ï¼Œä»¥ selfã€super æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦å¼€å¤´ã€‚

ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„éƒ½åè·Ÿä¸€ä¸ªæˆ–å¤šä¸ªåŒå†’å·`::`åˆ†å‰²ã€‚

æˆ‘ä»¬æ›´å€¾å‘äºä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œå› ä¸ºæŠŠä»£ç å®šä¹‰å’Œé¡¹è°ƒç”¨å„è‡ªç‹¬ç«‹åœ°ç§»åŠ¨æ˜¯æ›´å¸¸è§çš„ã€‚

Rust ä¸­é»˜è®¤æ‰€æœ‰é¡¹ï¼ˆå‡½æ•°ã€æ–¹æ³•ã€ç»“æ„ä½“ã€æšä¸¾ã€æ¨¡å—å’Œå¸¸é‡ï¼‰éƒ½æ˜¯ç§æœ‰çš„ã€‚çˆ¶æ¨¡å—ä¸­çš„é¡¹ä¸èƒ½ä½¿ç”¨å­æ¨¡å—ä¸­çš„ç§æœ‰é¡¹ï¼Œä½†æ˜¯å­æ¨¡å—ä¸­çš„é¡¹å¯ä»¥ä½¿ç”¨ä»–ä»¬çˆ¶æ¨¡å—ä¸­çš„é¡¹ã€‚è¿™æ˜¯å› ä¸ºå­æ¨¡å—å°è£…å¹¶éšè—äº†ä»–ä»¬çš„å®ç°è¯¦æƒ…ï¼Œä½†æ˜¯å­æ¨¡å—å¯ä»¥çœ‹åˆ°ä»–ä»¬å®šä¹‰çš„ä¸Šä¸‹æ–‡ã€‚

ç§æœ‰æ€§è§„åˆ™ä¸ä½†åº”ç”¨äºæ¨¡å—ï¼Œè¿˜åº”ç”¨äºç»“æ„ä½“ã€æšä¸¾ã€å‡½æ•°å’Œæ–¹æ³•ã€‚

#### pub å…±æœ‰ç»“æ„å’Œæšä¸¾

å¦‚æœæˆ‘ä»¬åœ¨ä¸€ä¸ªç»“æ„ä½“å®šä¹‰çš„å‰é¢ä½¿ç”¨äº† pub ï¼Œè¿™ä¸ªç»“æ„ä½“ä¼šå˜æˆå…¬æœ‰çš„ï¼Œä½†æ˜¯è¿™ä¸ªç»“æ„ä½“çš„å­—æ®µä»ç„¶æ˜¯ç§æœ‰çš„ã€‚
å¦‚æœæˆ‘ä»¬å°†æšä¸¾è®¾ä¸ºå…¬æœ‰ï¼Œåˆ™å®ƒçš„æ‰€æœ‰æˆå‘˜éƒ½å°†å˜ä¸ºå…¬æœ‰ã€‚

### 7.4 use å…³é”®å­—å¼•å…¥è·¯å¾„åˆ°ä½œç”¨åŸŸ

ç›®çš„ï¼šè§£å†³å…¨è·¯å¾„çš„å†—é•¿å’Œé‡å¤

åœ¨ä½œç”¨åŸŸä¸­å¢åŠ  use å’Œè·¯å¾„ç±»ä¼¼äºåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºè½¯è¿æ¥ï¼ˆç¬¦å·è¿æ¥ï¼Œsymbolic linkï¼‰ã€‚

è¦æƒ³ä½¿ç”¨ use å°†å‡½æ•°çš„çˆ¶æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼Œæˆ‘ä»¬å¿…é¡»åœ¨è°ƒç”¨å‡½æ•°æ—¶æŒ‡å®šçˆ¶æ¨¡å—ï¼Œè¿™æ ·å¯ä»¥æ¸…æ™°åœ°è¡¨æ˜å‡½æ•°ä¸æ˜¯åœ¨æœ¬åœ°å®šä¹‰çš„ï¼ŒåŒæ—¶ä½¿å®Œæ•´è·¯å¾„çš„é‡å¤åº¦æœ€å°åŒ–ã€‚
å¦ä¸€æ–¹é¢ï¼Œä½¿ç”¨ use å¼•å…¥ç»“æ„ä½“ã€æšä¸¾å’Œå…¶ä»–é¡¹æ—¶ï¼Œä¹ æƒ¯æ˜¯æŒ‡å®šå®ƒä»¬çš„å®Œæ•´è·¯å¾„ã€‚

    ğŸ¤” ä¹Ÿå°±æ˜¯è¯´ï¼Œé€šå¸¸ use æ¨¡å—å”¯ç‹¬å³å¯ï¼Œå¯ä»¥æ¸…æ™°åœ°è¡¨æ˜ä½¿ç”¨çš„æ–¹æ³•æ˜¯å±äºå“ªä¸ªæ¨¡å—çš„ã€‚ä½†æ˜¯åœ¨å¼•å…¥ç»“æ„é¢˜å’Œæšä¸¾æ—¶ï¼Œä¹ æƒ¯æ˜¯ç”¨å®Œæ•´è·¯å¾„ï¼Œè¿™æœ‰ç‚¹åƒå…¶ä»–è¯­è¨€ä¸­å¼•å…¥ä¸€ä¸ªå¸¸é‡ã€‚åªæ˜¯ä¹ æƒ¯ã€‚

ä¾‹å¤–:

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
    Ok(())
}
fn function2() -> io::Result<()> {
    // --snip--
    Ok(())
}
```

ä½¿ç”¨ as æä¾›åˆ«åï¼š

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
```

ä½¿ç”¨ pub use é‡å¯¼å‡º
ä¸ä»…å°†ä¸€ä¸ªåŸŸï¼Œè¿˜å…è®¸åˆ«äººæŠŠå®ƒå¯¼å…¥ä»–ä»¬è‡ªå·±çš„ä½œç”¨åŸŸã€‚

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
// é€šè¿‡ pub use é‡å¯¼å‡ºï¼Œå¤–éƒ¨ä»£ç ç°åœ¨å¯ä»¥é€šè¿‡æ–°è·¯å¾„ restaurant::hosting::add_to_waitlist æ¥è°ƒç”¨ add_to_waitlist å‡½æ•°ã€‚
// ç›¸å½“äº restaurant æœ‰äº† hosting pub mod
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

ä½¿ç”¨å¤–éƒ¨åŒ… package:
- åœ¨ Cargo.toml [dependencies] ä¸­å¼•å…¥
- use ä½¿ç”¨
- æ ‡å‡†åº“æ— éœ€å¼•å…¥ï¼Œç›´æ¥ä½¿ç”¨ std::ï¼ˆå¯¹äº String å…¶å®æ˜¯ prelude)

ğŸ¤” å¦‚æœæœ‰å¤§é‡çš„ useï¼Œæ˜¯å¦æœ‰ä¼˜åŒ–è¯­æ³•ï¼Ÿä½¿ç”¨åµŒå¥—

```rust
use std::cmp::Ordering;
use std::io;

use std::{cmp::Ordering, io};

use std::io;
use std::io::Write;
use std::io{self, Write};
```

ğŸ¤” æœ‰æ²¡æœ‰å¼•å…¥æ‰€æœ‰å…¬æœ‰å®šä¹‰çš„æ–¹å¼ï¼Ÿglob è¿ç®—ç¬¦ *

```rust
use std::collections::*;

glob è¿ç®—ç¬¦ç»å¸¸ç”¨äºæµ‹è¯•æ¨¡å— tests ä¸­ï¼Œè¿™æ—¶ä¼šå°†æ‰€æœ‰å†…å®¹å¼•å…¥ä½œç”¨åŸŸã€‚
```

### 7.5 æ¨¡å—æ‹†åˆ†

é—®é¢˜ï¼šå•ä¸ªæ¨¡å—æ–‡ä»¶ä¸­å¤šä¸ªæ¨¡å—æŒç»­è†¨èƒ€ï¼Œéœ€è¦ç®€åŒ–ä»£ç å¢åŠ å¯è¯»æ€§ã€‚

```rust
// ç”³æ˜å¼•å…¥ front_of_house æ¨¡å—
// front_of_house.rc
mod front_of_house;

pub use crate::front_of_house:hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

// å­æ¨¡å—
pub mod hosting;
// src/front_of_house/hosting.rs
```

## å…«ã€å¸¸è§é›†åˆ

- Vector: æœ‰åºå­˜å‚¨ä¸€ç³»åˆ—å¯å˜å€¼
- String: å­—ç¬¦çš„é›†åˆ
- HashMap: å“ˆå¸Œ map

### 8.1 Vector

- å†…å­˜ä¸­æ•°æ®ç›¸é‚»æ’åˆ—
- åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„å€¼

#### æ–°å»º Vector

```rust
let v: Vec<i32> = Vec::new();
let v = vec![1,2,3];
```

#### æ›´æ–° Vector
```rust
let mut v = Vec::new();

v.push(1);
v.push(2);
v.push(3);
```

#### é”€æ¯ Vector
```rust
{
    let v = vec![1,2,3];
} // leave scope here, drop
```

#### è¯»å– Vector å…ƒç´ 
```rust
let v = vec![1,2,3,4,5];
let third: &i32 = &v[2];
println!("The third vector is {}", third);
match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
// index is begin from 0
// use & and [] get element
// [] æ–¹å¼å¯ä»¥å¤„ç† out of bound çš„é—®é¢˜ï¼Œè¶…è¿‡ç´¢å¼•æœ€å¤§å€¼æ—¶ï¼Œè¿”å› None

let mut v = vec![1,2,3,4,5];
let first = &v[0]; // ä¸å¯å˜å¼•ç”¨
v.push(6); // å¯å˜å¼•ç”¨ï¼ˆæ‰©å®¹ï¼‰
// å¦‚æœ v æ²¡æœ‰è¶³å¤Ÿçš„ç©ºé—´å­˜å‚¨æ–°å…ƒç´ 
// rust ä¼šè¿›è¡Œè‡ªåŠ¨æ‰©å®¹ï¼Œæ­¤æ—¶éœ€è¦æ‹·è´åŸæ¥çš„å€¼åˆ°æ–°çš„ç©ºé—´ä¸­
println!("The first element is {}", first);
```

#### éå† Vector

```rust
let v = vec![1,2,3,4,5];
for i in &v {
    println!("{}", i);
}

let mut v = vec![100,200,300];
for i in &mut v {
    // è§£å¼•ç”¨è·å– i çš„å€¼
    *i += 50;
}
```

#### ä½¿ç”¨ enum å­˜å‚¨ä¸åŒç±»å‹çš„å€¼åˆ° Vector

æšä¸¾æˆå‘˜è¢«è®¤ä¸ºæ˜¯åŒä¸€ä¸ªæšä¸¾ç±»å‹ã€‚

```rust
enum DataTypes {
    Int(i32),
    Float(f64),
    Text(String),
    Ch(char),
}
let datas = vec![
    DataTypes::Int(100),
    DataTypes::Float(10.1),
    DataTypes::Text(String::from("china")),
    DataTypes::Ch('a'),
]
```
Rust åœ¨ç¼–è¯‘æ—¶å°±å¿…é¡»å‡†ç¡®çš„çŸ¥é“ vector ä¸­ç±»å‹çš„åŸå› åœ¨äºå®ƒéœ€è¦çŸ¥é“å‚¨å­˜æ¯ä¸ªå…ƒç´ åˆ°åº•éœ€è¦å¤šå°‘å†…å­˜ã€‚

### 8.2 String

### 8.3 HashMap